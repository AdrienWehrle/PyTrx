
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>PyTrx.Velocity &#8212; PyTrx 1.1.0 documentation</title>
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">PyTrx 1.1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for PyTrx.Velocity</h1><div class="highlight"><pre>
<span></span><span class="c1">#PyTrx (c) by Penelope How, Nick Hulton, Lynne Buie</span>
<span class="c1">#</span>
<span class="c1">#PyTrx is licensed under a MIT License.</span>
<span class="c1">#</span>
<span class="c1">#You should have received a copy of the license along with this</span>
<span class="c1">#work. If not, see &lt;https://choosealicense.com/licenses/mit/&gt;.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The Velocity module handles the functionality for obtaining velocity and </span>
<span class="sd">homography measurements from oblique time-lapse imagery. Specifically, this </span>
<span class="sd">module contains functions for: (1) Performing camera registration from static </span>
<span class="sd">point feature tracking (referred to here as homography); and (2) Calculating </span>
<span class="sd">surface velocities derived from feature tracking, with associated errors and </span>
<span class="sd">signal-to-noise ratio calculated. These functions can be performed with either</span>
<span class="sd">a sparse or dense method, using corner features for tracking in the sparse</span>
<span class="sd">method and a grid of evenly space points in the dense method.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1">#Import packages</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">path</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">interpolate</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="k">import</span> <span class="n">Image</span>
<span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>

<span class="c1">#Import PyTrx functions and classes</span>
<span class="kn">from</span> <span class="nn">FileHandler</span> <span class="k">import</span> <span class="n">readMask</span>
<span class="kn">from</span> <span class="nn">Images</span> <span class="k">import</span> <span class="n">ImageSequence</span>
<span class="kn">from</span> <span class="nn">CamEnv</span> <span class="k">import</span> <span class="n">projectUV</span><span class="p">,</span> <span class="n">projectXYZ</span><span class="p">,</span> <span class="n">setProjection</span>

<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="Homography"><a class="viewcode-back" href="../../source/Modules.html#PyTrx.Velocity.Homography">[docs]</a><span class="k">class</span> <span class="nc">Homography</span><span class="p">(</span><span class="n">ImageSequence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class for the processing the homography of an image sequence to </span>
<span class="sd">    determine motion in a camera platform. This class treats the images as a </span>
<span class="sd">    contigous sequence of name references by default.</span>
<span class="sd">    </span>
<span class="sd">    :param imageList: List of images, for the ImageSet object</span>
<span class="sd">    :type imageList: list</span>
<span class="sd">    :param camEnv: The Camera Environment corresponding to the images, for the :class:`PyTrx.Images.ImageSequence` object</span>
<span class="sd">    :type camEnv: :class:`PyTrx.CamEnv.CamEnv`</span>
<span class="sd">    :param invmaskPath: The mask for the stationary feature tracking (for camera registration/determining camera homography), default to None</span>
<span class="sd">    :type invmaskPath: arr, optional</span>
<span class="sd">    :param calibFlag: Flag denoting whether images should be corrected for lens distortion, default to True</span>
<span class="sd">    :type calibFlag: bool, optional</span>
<span class="sd">    :param band: String denoting the desired image band, default to &#39;L&#39; (grayscale)</span>
<span class="sd">    :type band: str, optional</span>
<span class="sd">    :param equal: Flag denoting whether histogram equalisation is applied to images (histogram equalisation is applied if True); default is True.                        </span>
<span class="sd">    :type equal: bool, optional    </span>
<span class="sd">    &quot;&quot;&quot;</span>      
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imageList</span><span class="p">,</span> <span class="n">camEnv</span><span class="p">,</span> <span class="n">invmaskPath</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">calibFlag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                 <span class="n">band</span><span class="o">=</span><span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="n">equal</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Homography object initialisation&#39;&#39;&#39;</span>
        <span class="n">ImageSequence</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imageList</span><span class="p">,</span> <span class="n">band</span><span class="p">,</span> <span class="n">equal</span><span class="p">)</span>
        
        <span class="c1">#Set initial class properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_camEnv</span> <span class="o">=</span> <span class="n">camEnv</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_imageN</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getLength</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calibFlag</span> <span class="o">=</span> <span class="n">calibFlag</span>
         
        <span class="c1">#Set mask</span>
        <span class="k">if</span> <span class="n">invmaskPath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invmask</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invmask</span> <span class="o">=</span> <span class="n">readMask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getImageArrNo</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">invmaskPath</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Homography mask set&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="Homography.calcHomographies"><a class="viewcode-back" href="../../source/Modules.html#PyTrx.Velocity.Homography.calcHomographies">[docs]</a>    <span class="k">def</span> <span class="nf">calcHomographies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">homogmethod</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">RANSAC</span><span class="p">,</span> 
                         <span class="n">ransacReprojThreshold</span><span class="o">=</span><span class="mf">5.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Function to generate a homography model through a sequence of </span>
<span class="sd">        images, and perform for image registration. Points that are assumed </span>
<span class="sd">        to be static in the image plane are tracked between image pairs, and </span>
<span class="sd">        movement in these points are used to generate sequential homography </span>
<span class="sd">        models.</span>
<span class="sd">        Input example:</span>
<span class="sd">        For sparse homographies:</span>
<span class="sd">        homog = Homography.calcHomographies([[&#39;sparse&#39;], [50000, 0.1, 5], </span>
<span class="sd">        [(25,25), 1.0, 4]])       </span>
<span class="sd">        For dense homographies:</span>
<span class="sd">        homog = Homography.calcHomographies([[&#39;dense&#39;], [100,100], </span>
<span class="sd">        [cv2.TM_CCORR_NORMED, 50, 100, 1.0, 4]])</span>
<span class="sd">        </span>
<span class="sd">        :param params: List that defines the parameters for point matching: Method: &#39;sparse&#39; or &#39;dense&#39; (str). Seed parameters: either containing the cornerparameters for the sparse method - max. number of corners (int), quality (int), and min. distance (int). Or the grid spacing (list) for the dense method. Tracking parameters: either containing the sparse method parameters - window size (tuple), backtracking threshold(int) and minimum tracked features (int). Or the dense method parameters - tracking method (int), template size (int), search window size (int), backtracking threshold (int), and minimum tracked features (int)</span>
<span class="sd">        :type params: list              </span>
<span class="sd">        :param homogmethod: Method used to calculate homography model, which plugs into the OpenCV function. This can either be cv2.RANSAC (a RANSAC-based robust method), cv2.LEAST_MEDIAN (a Least-Median robust method) or &#39;0&#39; (a regular method using all the points); default to cv2.RANSAC</span>
<span class="sd">        :type homogmethod: int, optional                                  </span>
<span class="sd">        :param ransacReprojThreshold: Maximum allowed reprojection error, default to 5.0</span>
<span class="sd">        :type ransacReprojThreshold: int                                     </span>
<span class="sd">        :returns: A list of homography information for all image pairs in sequence</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span> 
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">CALCULATING HOMOGRAPHY&#39;</span><span class="p">)</span>

        <span class="n">homog</span><span class="o">=</span><span class="p">[]</span>   
        
        <span class="c1">#Get first image (image0) path and array data</span>
        <span class="n">imn1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_imageSet</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">getImageName</span><span class="p">()</span>
        <span class="n">im1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_imageSet</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">getImageArray</span><span class="p">()</span>
        
        <span class="c1">#Cycle through image pairs (numbered from 0)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getLength</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            
            <span class="c1">#Re-assign first image in image pair</span>
            <span class="n">im0</span><span class="o">=</span><span class="n">im1</span>
            <span class="n">imn0</span><span class="o">=</span><span class="n">imn1</span>
            
            <span class="c1">#Get second image in image pair (clear memory subsequently)</span>
            <span class="n">im1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_imageSet</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">getImageArray</span><span class="p">()</span>
            <span class="n">imn1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_imageSet</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">getImageName</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_imageSet</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">clearImage</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_imageSet</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">clearImageArray</span><span class="p">()</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Processing homograpy for images: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">imn0</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; and &#39;</span> 
                  <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">imn1</span><span class="p">))</span>
            
            <span class="c1">#Get inverse mask and calibration parameters</span>
            <span class="n">invmask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getInverseMask</span><span class="p">()</span>
            <span class="n">cameraMatrix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_camEnv</span><span class="o">.</span><span class="n">getCamMatrixCV2</span><span class="p">()</span>
            <span class="n">distortP</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_camEnv</span><span class="o">.</span><span class="n">getDistortCoeffsCV2</span><span class="p">()</span>
            
            <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;sparse&#39;</span><span class="p">:</span>
                
                <span class="c1">#Calculate homography from corners </span>
                <span class="n">hg</span><span class="o">=</span><span class="n">calcSparseHomography</span><span class="p">(</span><span class="n">im0</span><span class="p">,</span> <span class="n">im1</span><span class="p">,</span> <span class="n">invmask</span><span class="p">,</span> <span class="p">[</span><span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distortP</span><span class="p">],</span> 
                                        <span class="n">homogmethod</span><span class="p">,</span> <span class="n">ransacReprojThreshold</span><span class="p">,</span>
                                        <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                                        <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                        <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]])</span>
                
            <span class="k">elif</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;dense&#39;</span><span class="p">:</span>
                
                <span class="c1">#Get camera environment </span>
                <span class="n">camenv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCamEnv</span><span class="p">()</span>
                
                <span class="c1">#Get DEM from camera environment</span>
                <span class="n">dem</span> <span class="o">=</span> <span class="n">camenv</span><span class="o">.</span><span class="n">getDEM</span><span class="p">()</span> 
        
                <span class="c1">#Get projection and inverse projection variables through camera info</span>
                <span class="n">projvars</span> <span class="o">=</span> <span class="p">[</span><span class="n">camenv</span><span class="o">.</span><span class="n">_camloc</span><span class="p">,</span> <span class="n">camenv</span><span class="o">.</span><span class="n">_camDirection</span><span class="p">,</span> <span class="n">camenv</span><span class="o">.</span><span class="n">_radCorr</span><span class="p">,</span> 
                            <span class="n">camenv</span><span class="o">.</span><span class="n">_tanCorr</span><span class="p">,</span> <span class="n">camenv</span><span class="o">.</span><span class="n">_focLen</span><span class="p">,</span> <span class="n">camenv</span><span class="o">.</span><span class="n">_camCen</span><span class="p">,</span> 
                            <span class="n">camenv</span><span class="o">.</span><span class="n">_refImage</span><span class="p">]</span>
        
                <span class="c1">#Calculate homography from grid</span>
                <span class="n">hg</span><span class="o">=</span><span class="n">calcDenseHomography</span><span class="p">(</span><span class="n">im0</span><span class="p">,</span> <span class="n">im1</span><span class="p">,</span> <span class="n">invmask</span><span class="p">,</span> 
                                       <span class="p">[</span><span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">distortP</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> 
                                       <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">dem</span><span class="p">,</span> <span class="n">projvars</span><span class="p">,</span> 
                                       <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">homogmethod</span><span class="p">,</span> 
                                       <span class="n">ransacReprojThreshold</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span>
                                       <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">4</span><span class="p">])</span>
        
            <span class="c1">#Assign homography information as object attributes</span>
            <span class="n">homog</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hg</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">homog</span>            </div>


<div class="viewcode-block" id="Homography.getInverseMask"><a class="viewcode-back" href="../../source/Modules.html#PyTrx.Velocity.Homography.getInverseMask">[docs]</a>    <span class="k">def</span> <span class="nf">getInverseMask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Return inverse mask.&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invmask</span></div></div>

            
<div class="viewcode-block" id="Velocity"><a class="viewcode-back" href="../../source/Modules.html#PyTrx.Velocity.Velocity">[docs]</a><span class="k">class</span> <span class="nc">Velocity</span><span class="p">(</span><span class="n">ImageSequence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class for the processing of an ImageSet to determine pixel </span>
<span class="sd">    displacements and real-world velocities from a sparse set of points, with </span>
<span class="sd">    methods to track in the xy image plane and project tracks to real-world </span>
<span class="sd">    (xyz) coordinates. This class treats the images as a contigous sequence of </span>
<span class="sd">    name references by default.</span>
<span class="sd">    </span>
<span class="sd">    :param imageList: List of images, for the :class:`PyTrx.Images.ImageSequence` object</span>
<span class="sd">    :type imageList: list</span>
<span class="sd">    :param camEnv:  The Camera Environment object, :class:`PyTrx.CamEnv.CamEnv` corresponding to the images</span>
<span class="sd">    :type camEnv: :class:`PyTrx.CamEnv.CamEnv`</span>
<span class="sd">    :param homography: Homography model for the corresponding image, defaults to None</span>
<span class="sd">    :type homography: list, optional</span>
<span class="sd">    :param maskPath: The file path for the mask indicating the target area for deriving velocities from. If this file exists, the mask will be loaded. If this file does not exist, then the mask generation process will load, and the result will be saved with this path; default to None</span>
<span class="sd">    :type maskPath: str, optional</span>
<span class="sd">    :param calibFlag: Flag denoting whether images should be corrected for lens distortion, default to True</span>
<span class="sd">    :type calibFlag: bool, optional</span>
<span class="sd">    :param band: String denoting the desired image band, default to &#39;L&#39; (grayscale)</span>
<span class="sd">    :type band: str, optional</span>
<span class="sd">    :param equal: Flag denoting whether histogram equalisation is applied to images (histogram equalisation is applied if True); default is True.                        </span>
<span class="sd">    :type equal: bool, optional </span>
<span class="sd">    &quot;&quot;&quot;</span>        
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imageList</span><span class="p">,</span> <span class="n">camEnv</span><span class="p">,</span> <span class="n">homography</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maskPath</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                 <span class="n">calibFlag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">band</span><span class="o">=</span><span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="n">equal</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Velocity object initialisation&#39;&#39;&#39;</span>        
        <span class="n">ImageSequence</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imageList</span><span class="p">,</span> <span class="n">band</span><span class="p">,</span> <span class="n">equal</span><span class="p">)</span>
        
        <span class="c1">#Set initial class properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_camEnv</span> <span class="o">=</span> <span class="n">camEnv</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_homog</span> <span class="o">=</span> <span class="n">homography</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_imageN</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getLength</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calibFlag</span> <span class="o">=</span> <span class="n">calibFlag</span>
        
        <span class="c1">#Set mask </span>
        <span class="k">if</span> <span class="n">maskPath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">readMask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getImageArrNo</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">maskPath</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Velocity mask set&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="Velocity.calcVelocities"><a class="viewcode-back" href="../../source/Modules.html#PyTrx.Velocity.Velocity.calcVelocities">[docs]</a>    <span class="k">def</span> <span class="nf">calcVelocities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Function to calculate velocities between succesive image pairs. </span>
<span class="sd">        Image pairs are called from the ImageSequence object. Points are seeded</span>
<span class="sd">        in the first of these pairs using the Shi-Tomasi algorithm with </span>
<span class="sd">        OpenCV&#39;s goodFeaturesToTrack function.         </span>
<span class="sd">        The Lucas Kanade optical flow algorithm is applied using the OpenCV </span>
<span class="sd">        function calcOpticalFlowPyrLK to find these tracked points in the </span>
<span class="sd">        second image of each image pair. A backward tracking method then tracks </span>
<span class="sd">        back from these to the first image in the pair, checking if this is </span>
<span class="sd">        within a certain distance as a validation measure.        </span>
<span class="sd">        Tracked points are corrected for image distortion and camera platform</span>
<span class="sd">        motion (if needed). The points in each image pair are georectified </span>
<span class="sd">        subsequently to obtain xyz points. The georectification functions are </span>
<span class="sd">        called from the Camera Environment object, and are based on those in</span>
<span class="sd">        ImGRAFT (Messerli and Grinsted, 2015). Velocities are finally derived </span>
<span class="sd">        from these using a simple Pythagoras&#39; theorem method.</span>
<span class="sd">        This function returns the xyz velocities and points from each image </span>
<span class="sd">        pair, and their corresponding uv velocities and points in the image </span>
<span class="sd">        plane.</span>
<span class="sd">        </span>
<span class="sd">        :param params: List that defines the parameters for deriving velocity: Method: &#39;sparse&#39; or &#39;dense&#39; (str). Seed parameters: either containing the corner parameters for the sparse method - max. number of corners (int), quality (int), and min. distance (int). Or the grid spacing (list) for the dense method. Tracking parameters: either containing the sparse method parameters - window size (tuple), backtracking threshold (int) and minimum tracked features (int). Or the dense method parameters - tracking method (int), template size (int), search window size (int), correlation threshold (int), and minimum tracked features (int)</span>
<span class="sd">        :type params: str</span>
<span class="sd">        :returns: A ist containing the xyz and uv velocities. The first element holds the xyz velocity for each point (xyz[0]), the xyz positions for the points in the first image (xyz[1]), and the xyz positions for the points in the second image(xyz[2]). The second element contains the uv velocities for each point (uv[0], the uv positions for the points in the first image (uv[1]), the uv positions for the points in the second image (uv[2]), and the corrected uv points in the second image if they have been calculated using the homography model for image registration (uv[3]). If the corrected points have not beencalculated then an empty list is merely returned</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>         
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">CALCULATING VELOCITIES&#39;</span><span class="p">)</span>
        <span class="n">velocity</span><span class="o">=</span><span class="p">[]</span>

        <span class="c1">#Get camera environment </span>
        <span class="n">camenv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCamEnv</span><span class="p">()</span>
        
        <span class="c1">#Get DEM from camera environment</span>
        <span class="n">dem</span> <span class="o">=</span> <span class="n">camenv</span><span class="o">.</span><span class="n">getDEM</span><span class="p">()</span> 

        <span class="c1">#Get projection and inverse projection variables through camera info</span>
        <span class="n">projvars</span> <span class="o">=</span> <span class="p">[</span><span class="n">camenv</span><span class="o">.</span><span class="n">_camloc</span><span class="p">,</span> <span class="n">camenv</span><span class="o">.</span><span class="n">_camDirection</span><span class="p">,</span> <span class="n">camenv</span><span class="o">.</span><span class="n">_radCorr</span><span class="p">,</span> 
                    <span class="n">camenv</span><span class="o">.</span><span class="n">_tanCorr</span><span class="p">,</span> <span class="n">camenv</span><span class="o">.</span><span class="n">_focLen</span><span class="p">,</span> <span class="n">camenv</span><span class="o">.</span><span class="n">_camCen</span><span class="p">,</span> 
                    <span class="n">camenv</span><span class="o">.</span><span class="n">_refImage</span><span class="p">]</span>
        
        <span class="c1">#Get inverse projection variables through camera info               </span>
        <span class="n">invprojvars</span> <span class="o">=</span> <span class="n">setProjection</span><span class="p">(</span><span class="n">dem</span><span class="p">,</span> <span class="n">camenv</span><span class="o">.</span><span class="n">_camloc</span><span class="p">,</span> <span class="n">camenv</span><span class="o">.</span><span class="n">_camDirection</span><span class="p">,</span> 
                                    <span class="n">camenv</span><span class="o">.</span><span class="n">_radCorr</span><span class="p">,</span> <span class="n">camenv</span><span class="o">.</span><span class="n">_tanCorr</span><span class="p">,</span> 
                                    <span class="n">camenv</span><span class="o">.</span><span class="n">_focLen</span><span class="p">,</span> <span class="n">camenv</span><span class="o">.</span><span class="n">_camCen</span><span class="p">,</span> 
                                    <span class="n">camenv</span><span class="o">.</span><span class="n">_refImage</span><span class="p">)</span> 
        
        <span class="c1">#Get camera matrix and distortion parameters for calibration</span>
        <span class="n">mtx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_camEnv</span><span class="o">.</span><span class="n">getCamMatrixCV2</span><span class="p">()</span>
        <span class="n">distort</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_camEnv</span><span class="o">.</span><span class="n">getDistortCoeffsCV2</span><span class="p">()</span>
        
        <span class="c1">#Get mask</span>
        <span class="n">mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getMask</span><span class="p">()</span>
        
        <span class="c1">#Get first image (image0) file path and array data for initial tracking</span>
        <span class="n">imn1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_imageSet</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">getImageName</span><span class="p">()</span>
        <span class="n">im1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_imageSet</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">getImageArray</span><span class="p">()</span>
        
        <span class="c1">#Cycle through image pairs (numbered from 0)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getLength</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>

            <span class="c1">#Re-assign first image in image pair</span>
            <span class="n">im0</span><span class="o">=</span><span class="n">im1</span>
            <span class="n">imn0</span><span class="o">=</span><span class="n">imn1</span>
                            
            <span class="c1">#Get second image in image pair (and subsequently clear memory)</span>
            <span class="n">im1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_imageSet</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">getImageArray</span><span class="p">()</span>
            <span class="n">imn1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_imageSet</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">getImageName</span><span class="p">()</span>       
            <span class="bp">self</span><span class="o">.</span><span class="n">_imageSet</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">clearAll</span><span class="p">()</span>
           
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Feature-tracking for images: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">imn0</span><span class="p">)</span> <span class="o">+</span><span class="s1">&#39; and &#39;</span> 
                  <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">imn1</span><span class="p">))</span>        

            <span class="c1">#Calculate velocities between image pair with homography</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_homog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;sparse&#39;</span><span class="p">:</span>
                    <span class="n">pts</span><span class="o">=</span><span class="n">calcSparseVelocity</span><span class="p">(</span><span class="n">im0</span><span class="p">,</span> <span class="n">im1</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="p">[</span><span class="n">mtx</span><span class="p">,</span><span class="n">distort</span><span class="p">],</span> 
                                           <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_homog</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> 
                                           <span class="bp">self</span><span class="o">.</span><span class="n">_homog</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">]],</span> 
                                           <span class="n">invprojvars</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> 
                                           <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> 
                                           <span class="p">[</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> 
                                           <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]])</span> 
                    
                <span class="k">elif</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;dense&#39;</span><span class="p">:</span>
                    <span class="n">pts</span><span class="o">=</span><span class="n">calcDenseVelocity</span><span class="p">(</span><span class="n">im0</span><span class="p">,</span> <span class="n">im1</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                          <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>
                                          <span class="n">mask</span><span class="p">,</span> <span class="p">[</span><span class="n">mtx</span><span class="p">,</span><span class="n">distort</span><span class="p">],</span> 
                                          <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_homog</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> 
                                          <span class="bp">self</span><span class="o">.</span><span class="n">_homog</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">]],</span> <span class="p">[</span><span class="n">dem</span><span class="p">,</span> <span class="n">projvars</span><span class="p">,</span> 
                                          <span class="n">invprojvars</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span>
                                          <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">4</span><span class="p">])</span>
                       
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;sparse&#39;</span><span class="p">:</span>
                    <span class="n">pts</span><span class="o">=</span><span class="n">calcSparseVelocity</span><span class="p">(</span><span class="n">im0</span><span class="p">,</span> <span class="n">im1</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="p">[</span><span class="n">mtx</span><span class="p">,</span><span class="n">distort</span><span class="p">],</span> 
                                           <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">invprojvars</span><span class="p">,</span> 
                                           <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> 
                                           <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> 
                                           <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]])</span>
                        
                <span class="k">elif</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;dense&#39;</span><span class="p">:</span>
                    <span class="n">pts</span><span class="o">=</span><span class="n">calcDenseVelocity</span><span class="p">(</span><span class="n">im0</span><span class="p">,</span> <span class="n">im1</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                          <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>
                                          <span class="n">mask</span><span class="p">,</span> <span class="p">[</span><span class="n">mtx</span><span class="p">,</span><span class="n">distort</span><span class="p">],</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> 
                                          <span class="p">[</span><span class="n">dem</span><span class="p">,</span> <span class="n">projvars</span><span class="p">,</span> <span class="n">invprojvars</span><span class="p">],</span> 
                                          <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">4</span><span class="p">])</span>                     
                                                 
            <span class="c1">#Append output</span>
            <span class="n">velocity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>         
        
        <span class="c1">#Return XYZ and UV velocity information</span>
        <span class="k">return</span> <span class="n">velocity</span></div>
       
        
<div class="viewcode-block" id="Velocity.getMask"><a class="viewcode-back" href="../../source/Modules.html#PyTrx.Velocity.Velocity.getMask">[docs]</a>    <span class="k">def</span> <span class="nf">getMask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the image mask.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span></div>
 
 
<div class="viewcode-block" id="Velocity.getCamEnv"><a class="viewcode-back" href="../../source/Modules.html#PyTrx.Velocity.Velocity.getCamEnv">[docs]</a>    <span class="k">def</span> <span class="nf">getCamEnv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the camera environment object (CamEnv).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_camEnv</span></div></div>
    

<span class="c1">#------------------------------------------------------------------------------    </span>

<div class="viewcode-block" id="calcSparseVelocity"><a class="viewcode-back" href="../../source/Modules.html#PyTrx.Velocity.calcSparseVelocity">[docs]</a><span class="k">def</span> <span class="nf">calcSparseVelocity</span><span class="p">(</span><span class="n">img1</span><span class="p">,</span> <span class="n">img2</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">calib</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">homog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                       <span class="n">invprojvars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">winsize</span><span class="o">=</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span><span class="mi">25</span><span class="p">),</span> <span class="n">back_thresh</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> 
                       <span class="n">min_features</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">seedparams</span><span class="o">=</span><span class="p">[</span><span class="mi">50000</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;Function to calculate the velocity between a pair of images. Points </span>
<span class="sd">    are seeded in the first of these either by a defined grid spacing, or using </span>
<span class="sd">    the Shi-Tomasi algorithm with OpenCV&#39;s goodFeaturesToTrack function.  </span>
<span class="sd">    The Lucas Kanade optical flow algorithm is applied using the OpenCV </span>
<span class="sd">    function calcOpticalFlowPyrLK to find these tracked points in the </span>
<span class="sd">    second image. A backward tracking method then tracks back from these to </span>
<span class="sd">    the original points, checking if this is within a certain distance as a </span>
<span class="sd">    validation measure.</span>
<span class="sd">    Tracked points are corrected for image distortion and camera platform</span>
<span class="sd">    motion (if needed). The points in the image pair are georectified </span>
<span class="sd">    subsequently to obtain xyz points.  The georectification functions are </span>
<span class="sd">    called from the :class:`PyTrx.CamEnv.CamEnv` object, and are based on those </span>
<span class="sd">    in ImGRAFT (Messerli and Grinsted, 2015). Velocities are finally derived</span>
<span class="sd">    from these using a simple Pythagoras&#39; theorem method. This function returns </span>
<span class="sd">    the xyz velocities and points, and their corresponding uv velocities and </span>
<span class="sd">    points in the image plane.</span>
<span class="sd">    </span>
<span class="sd">    :param img1: Image 1 in the image pair</span>
<span class="sd">    :type img1: arr                 </span>
<span class="sd">    :param img2: Image 2 in the image pair</span>
<span class="sd">    :type img2: arr</span>
<span class="sd">    :param mask: </span>
<span class="sd">    :type mask: arr</span>
<span class="sd">    :param calib: default to None</span>
<span class="sd">    :type calib: list, optional</span>
<span class="sd">    :param homog: default to None</span>
<span class="sd">    :type homog: list, optional</span>
<span class="sd">    :param invprojvars: default to None</span>
<span class="sd">    :type invprojvars: list, optional</span>
<span class="sd">    :param winsize: default to (25, 25)</span>
<span class="sd">    :type winsize: tuple, optional</span>
<span class="sd">    :param back_thesh: Threshold for back-tracking distance (i.e.the difference between the original seeded point and the back-tracked point in im0); default to 1.0</span>
<span class="sd">    :type back_thresh: int, optional</span>
<span class="sd">    :param min_features: Minimum number of seeded points to track, default to 4</span>
<span class="sd">    :type min_features: int, optional</span>
<span class="sd">    :param seedparams: Point seeding parameters, which indicate whether points are generated based on corner features or a grid with defined spacing. The three corner features parameters denote maximum number of corners detected, corner quality, and minimum distance between corners; inputted as a list. For grid generation, the only input parameter needed is the grid spacing; inputted as a list containing the horizontal and vertical grid spacing. Default to [50000, 0.1, 5.0]</span>
<span class="sd">    :type seedparams: list, optional                           </span>
<span class="sd">    :returns: Two lists, 1. The xyz velocities for each point (xyz[0]), the xyz positions for the points in the first image (xyz[1]), and the xyz positions for the points in the second image(xyz[2]); 2. The uv velocities for each point (uv[0], the uv positions for the points in the first image (uv[1]), the uv positions for the points in the second image (uv[2]), and the corrected uv points in the second image if they have been calculated using the homography model for image registration (uv[3]). If the corrected points have not been calculated then an empty list is merely returned </span>
<span class="sd">    :rtype: list                                </span>
<span class="sd">    &quot;&quot;&quot;</span>      
    <span class="c1">#Set threshold difference for homography correction</span>
    <span class="n">displacement_tolerance_rel</span><span class="o">=</span><span class="mf">2.0</span>
    
    <span class="c1">#Seed features</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="n">seedCorners</span><span class="p">(</span><span class="n">img1</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">seedparams</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seedparams</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> 
                     <span class="n">seedparams</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">min_features</span><span class="p">)</span>
    
    <span class="c1">#Track points between the image pair</span>
    <span class="n">points</span><span class="p">,</span> <span class="n">ptserrors</span> <span class="o">=</span> <span class="n">opticalMatch</span><span class="p">(</span><span class="n">img1</span><span class="p">,</span> <span class="n">img2</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">winsize</span><span class="p">,</span> <span class="n">back_thresh</span><span class="p">,</span>  
                                     <span class="n">min_features</span><span class="p">)</span> 
 
    <span class="c1">#Pass empty object if tracking was insufficient</span>
    <span class="k">if</span> <span class="n">points</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">No features to undertake velocity measurements&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>        
        
    <span class="k">if</span> <span class="n">calib</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>        
        <span class="c1">#Calculate optimal camera matrix </span>
        <span class="n">size</span><span class="o">=</span><span class="n">img1</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">newMat</span><span class="p">,</span> <span class="n">roi</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">getOptimalNewCameraMatrix</span><span class="p">(</span><span class="n">calib</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                                                    <span class="n">calib</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> 
                                                    <span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">h</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">h</span><span class="p">))</span>
        
        <span class="c1">#Correct tracked points for image distortion. The displacement here </span>
        <span class="c1">#is defined forwards (i.e. the points in image 1 are first </span>
        <span class="c1">#corrected, followed by those in image 2)      </span>
        <span class="c1">#Correct points in first image </span>
        <span class="n">src_pts_corr</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">undistortPoints</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">calib</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">calib</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">P</span><span class="o">=</span><span class="n">newMat</span><span class="p">)</span>
        
        <span class="c1">#Correct points in second image                                         </span>
        <span class="n">dst_pts_corr</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">undistortPoints</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">calib</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">calib</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">P</span><span class="o">=</span><span class="n">newMat</span><span class="p">)</span>
        
        <span class="n">back_pts_corr</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">undistortPoints</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">calib</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">calib</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">P</span><span class="o">=</span><span class="n">newMat</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">src_pts_corr</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dst_pts_corr</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">back_pts_corr</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1">#Calculate homography-corrected pts if desired</span>
    <span class="k">if</span> <span class="n">homog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        
        <span class="c1">#Get homography matrix and homography points</span>
        <span class="n">hmatrix</span><span class="o">=</span><span class="n">homog</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">hpts</span><span class="o">=</span><span class="n">homog</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c1">#Apply perspective homography matrix to tracked points</span>
        <span class="n">dst_pts_homog</span> <span class="o">=</span> <span class="n">apply_persp_homographyPts</span><span class="p">(</span><span class="n">dst_pts_corr</span><span class="p">,</span> <span class="n">hmatrix</span><span class="p">,</span>
                                                  <span class="n">inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="c1">#Calculate difference between points corrected for homography and</span>
        <span class="c1">#those uncorrected for homography</span>
        <span class="n">dispx</span><span class="o">=</span><span class="n">dst_pts_homog</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">src_pts_corr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dispy</span><span class="o">=</span><span class="n">dst_pts_homog</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">src_pts_corr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c1">#Use pythagoras&#39; theorem to obtain distance</span>
        <span class="n">disp_dist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dispx</span><span class="o">*</span><span class="n">dispx</span><span class="o">+</span><span class="n">dispy</span><span class="o">*</span><span class="n">dispy</span><span class="p">)</span>
        
        <span class="c1">#Determine threshold for good points using a given displacement </span>
        <span class="c1">#tolerance (defined earlier)</span>
        <span class="n">xsd</span><span class="o">=</span><span class="n">hpts</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">ysd</span><span class="o">=</span><span class="n">hpts</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">sderr</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">xsd</span><span class="o">*</span><span class="n">xsd</span><span class="o">+</span><span class="n">ysd</span><span class="o">*</span><span class="n">ysd</span><span class="p">)</span>
        <span class="n">good</span><span class="o">=</span><span class="n">disp_dist</span> <span class="o">&gt;</span> <span class="n">sderr</span> <span class="o">*</span> <span class="n">displacement_tolerance_rel</span>
        
        <span class="c1">#Keep good points</span>
        <span class="n">src_pts_corr</span><span class="o">=</span><span class="n">src_pts_corr</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>
        <span class="n">dst_pts_corr</span><span class="o">=</span><span class="n">dst_pts_corr</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>
        <span class="n">dst_pts_homog</span><span class="o">=</span><span class="n">dst_pts_homog</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>
        <span class="n">back_pts_corr</span><span class="o">=</span><span class="n">back_pts_corr</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>
        <span class="n">ptserrors</span><span class="o">=</span><span class="n">ptserrors</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">dst_pts_corr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> 
              <span class="s1">&#39; points remaining after homography correction&#39;</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#Original tracked points assigned if homography not given</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Homography matrix not supplied. Original tracked points kept&#39;</span><span class="p">)</span>
        <span class="n">dst_pts_homog</span><span class="o">=</span><span class="n">dst_pts_corr</span>
    
    <span class="c1">#Calculate pixel velocity</span>
    <span class="n">pxvel</span><span class="o">=</span><span class="p">[]</span>       
    <span class="k">for</span> <span class="n">c</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">src_pts_corr</span><span class="p">,</span> <span class="n">dst_pts_homog</span><span class="p">):</span>                        
        <span class="n">pxvel</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span>
                     <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])))</span>
        
    <span class="c1">#Project good points (original and tracked) to obtain XYZ coordinates</span>
    <span class="k">if</span> <span class="n">invprojvars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>        
        <span class="c1">#Project good points from image0</span>
        <span class="n">uvs</span><span class="o">=</span><span class="n">src_pts_corr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="n">xyzs</span><span class="o">=</span><span class="n">projectUV</span><span class="p">(</span><span class="n">uvs</span><span class="p">,</span> <span class="n">invprojvars</span><span class="p">)</span>
        
        <span class="c1">#Project good points from image1</span>
        <span class="n">uvd</span><span class="o">=</span><span class="n">dst_pts_homog</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="n">xyzd</span><span class="o">=</span><span class="n">projectUV</span><span class="p">(</span><span class="n">uvd</span><span class="p">,</span> <span class="n">invprojvars</span><span class="p">)</span>

        <span class="c1">#Project good points from image0 back-tracked</span>
        <span class="n">uvb</span><span class="o">=</span><span class="n">back_pts_corr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="n">xyzb</span><span class="o">=</span><span class="n">projectUV</span><span class="p">(</span><span class="n">uvb</span><span class="p">,</span> <span class="n">invprojvars</span><span class="p">)</span>
        
        <span class="c1">#Calculate xyz velocity</span>
        <span class="n">xyzvel</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xyzs</span><span class="p">,</span> <span class="n">xyzd</span><span class="p">):</span>                        
            <span class="n">xyzvel</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span>
                         <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
        
        <span class="c1">#Calculate xyz error</span>
        <span class="n">xyzerr</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xyzs</span><span class="p">,</span> <span class="n">xyzb</span><span class="p">):</span>
            <span class="n">xyzerr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span>
                         <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xyzs</span><span class="o">=</span><span class="kc">None</span>
        <span class="n">xyzd</span><span class="o">=</span><span class="kc">None</span>
        <span class="n">xyzvel</span><span class="o">=</span><span class="kc">None</span>
        <span class="n">xyzerr</span><span class="o">=</span><span class="kc">None</span>
            
    <span class="c1">#Return real-world point positions (original and tracked points),</span>
    <span class="c1">#and xy pixel positions (original, tracked, and homography-corrected)</span>
    <span class="k">if</span> <span class="n">homog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[[</span><span class="n">xyzvel</span><span class="p">,</span> <span class="n">xyzs</span><span class="p">,</span> <span class="n">xyzd</span><span class="p">,</span> <span class="n">xyzerr</span><span class="p">],</span> 
                <span class="p">[</span><span class="n">pxvel</span><span class="p">,</span> <span class="n">src_pts_corr</span><span class="p">,</span> <span class="n">dst_pts_corr</span><span class="p">,</span> <span class="n">dst_pts_homog</span><span class="p">,</span> <span class="n">ptserrors</span><span class="p">]]</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[[</span><span class="n">xyzvel</span><span class="p">,</span> <span class="n">xyzs</span><span class="p">,</span> <span class="n">xyzd</span><span class="p">,</span> <span class="n">xyzerr</span><span class="p">],</span> 
                <span class="p">[</span><span class="n">pxvel</span><span class="p">,</span> <span class="n">src_pts_corr</span><span class="p">,</span> <span class="n">dst_pts_corr</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ptserrors</span><span class="p">]]</span></div>
        

<div class="viewcode-block" id="calcDenseVelocity"><a class="viewcode-back" href="../../source/Modules.html#PyTrx.Velocity.calcDenseVelocity">[docs]</a><span class="k">def</span> <span class="nf">calcDenseVelocity</span><span class="p">(</span><span class="n">im0</span><span class="p">,</span> <span class="n">im1</span><span class="p">,</span> <span class="n">griddistance</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">templatesize</span><span class="p">,</span> 
                      <span class="n">searchsize</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">calib</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">homog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">campars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                      <span class="n">threshold</span><span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span> <span class="n">min_features</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to calculate the velocity between a pair of images using </span>
<span class="sd">    a gridded template matching approach. Gridded points are defined by grid </span>
<span class="sd">    distance, which are then used to either generate templates for matching</span>
<span class="sd">    or tracked using the Lucas Kanade optical flow algorithm.    </span>
<span class="sd">    Tracked points are corrected for image distortion and camera platform</span>
<span class="sd">    motion (if needed). The points in the image pair are georectified </span>
<span class="sd">    subsequently to obtain xyz points.  The georectification functions are </span>
<span class="sd">    called from the Camera Environment object, and are based on those in</span>
<span class="sd">    ImGRAFT (Messerli and Grinsted, 2015). Velocities are finally derived</span>
<span class="sd">    from these using a simple Pythagoras&#39; theorem method. This function returns </span>
<span class="sd">    the xyz velocities and points, and their corresponding uv velocities and </span>
<span class="sd">    points in the image plane.</span>
<span class="sd">    </span>
<span class="sd">    :param im0: Image 1 in the image pair</span>
<span class="sd">    :type im0: arr</span>
<span class="sd">    :param im1: Image 2 in the image pair                  </span>
<span class="sd">    :type im1: arr                  </span>
<span class="sd">    :param griddistance: Grid spacing, defined by two values representing pixel row and column spacing.</span>
<span class="sd">    :type griddistance: list</span>
<span class="sd">    :param method: (str/int): Method for tmeplate matching: cv2.TM_CCOEFF - Cross-coefficient; cv2.TM_CCOEFF_NORMED - Normalised cross-coeff; cv2.TM_CCORR - Cross correlation; cv2.TM_CCORR_NORMED - Normalised cross-corr; cv2.TM_SQDIFF - Square difference; cv2.TM_SQDIFF_NORMED - Normalised square diff</span>
<span class="sd">    :type method: int</span>
<span class="sd">    :param templatesize: Template window size in im0 for matching</span>
<span class="sd">    :type templatesize: int</span>
<span class="sd">    :param searchsize: Search window size in im1 for matching</span>
<span class="sd">    :type searchsize: int               </span>
<span class="sd">    :param mask: Mask array for masking DEM</span>
<span class="sd">    :type mask: arr</span>
<span class="sd">    :param calib: Calibration parameters, default to None</span>
<span class="sd">    :type calib: list, optional</span>
<span class="sd">    :param homog: Homography parameters, hmatrix (arr) and hpts (arr), default to None</span>
<span class="sd">    :type homog: list, optional</span>
<span class="sd">    :param campars: List containing information for transforming between the image plane and 3D scene: 1. DEM (ExplicitRaster object); 2. Projection parameters (camera location, camera position, radial distortion coefficients, tangential distortion coefficients, focal length, camera centre, and reference image); 3. Inverse projection parameters (coordinate system  3D scene - X, Y, Z, uv0). Default to None    </span>
<span class="sd">    :type campar: list, optioanl    </span>
<span class="sd">    :param theshold: Threshold for template correlation; default to 0.8</span>
<span class="sd">    :type threshold: int, optional</span>
<span class="sd">    :param min_features: Minimum number of seeded points to track, default to 4</span>
<span class="sd">    :type min_features: int, optional</span>
<span class="sd">    :returns: Two lists, 1. containing the xyz velocities for each point (xyz[0]), the xyz positions for the points in the first image (xyz[1]), and the  xyz positions for the points in the second image(xyz[2]); amd 2. containing the uv velocities for each point (uv[0], the uv positions for the points in the first image (uv[1]), the uv positions for the points in the second image (uv[2]), and the corrected uv points in the second image if they have been calculated using the homography model for image registration (uv[3]). If the corrected points have not been calculated then an empty list is merely returned </span>
<span class="sd">    :rtype: list                                </span>
<span class="sd">    &quot;&quot;&quot;</span>       
    <span class="c1">#Set threshold difference for point tracks</span>
    <span class="n">displacement_tolerance_rel</span><span class="o">=</span><span class="mf">2.0</span>
    
    <span class="c1">#Seed point grid</span>
    <span class="n">xyz0</span><span class="p">,</span> <span class="n">uv0</span> <span class="o">=</span> <span class="n">seedGrid</span><span class="p">(</span><span class="n">campars</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">griddistance</span><span class="p">,</span> <span class="n">campars</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mask</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">uv0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39; templates generated&#39;</span><span class="p">)</span>
    
    <span class="c1">#Template match if method flag is not optical flow</span>
    <span class="n">pts</span><span class="p">,</span> <span class="n">ptserrors</span> <span class="o">=</span> <span class="n">templateMatch</span><span class="p">(</span><span class="n">im0</span><span class="p">,</span> <span class="n">im1</span><span class="p">,</span> <span class="n">uv0</span><span class="p">,</span> <span class="n">templatesize</span><span class="p">,</span> <span class="n">searchsize</span><span class="p">,</span> 
                                   <span class="n">threshold</span><span class="p">,</span> <span class="n">min_features</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
 
    <span class="c1">#Pass empty object if tracking was insufficient</span>
    <span class="k">if</span> <span class="n">pts</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">No features to undertake velocity measurements&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>        
    
    <span class="c1">#Correct point tracks for camera distortion    </span>
    <span class="k">if</span> <span class="n">calib</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
        
        <span class="c1">#Calculate optimal camera matrix </span>
        <span class="n">size</span><span class="o">=</span><span class="n">im0</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">newMat</span><span class="p">,</span> <span class="n">roi</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">getOptimalNewCameraMatrix</span><span class="p">(</span><span class="n">calib</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                                                    <span class="n">calib</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> 
                                                    <span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">h</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">h</span><span class="p">))</span>
        
        <span class="c1">#Correct tracked points for image distortion. The displacement here </span>
        <span class="c1">#is defined forwards (i.e. the points in image 1 are first </span>
        <span class="c1">#corrected, followed by those in image 2)      </span>
        <span class="c1">#Correct points in first image </span>
        <span class="n">src_pts_corr</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">undistortPoints</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                                         <span class="n">calib</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                                         <span class="n">calib</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">P</span><span class="o">=</span><span class="n">newMat</span><span class="p">)</span>
        
        <span class="c1">#Correct points in second image                                         </span>
        <span class="n">dst_pts_corr</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">undistortPoints</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> 
                                         <span class="n">calib</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                                         <span class="n">calib</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">P</span><span class="o">=</span><span class="n">newMat</span><span class="p">)</span>
    
    <span class="c1">#Return uncorrected points if calibration not given        </span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">src_pts_corr</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dst_pts_corr</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1">#Calculate homography-corrected pts if desired</span>
    <span class="k">if</span> <span class="n">homog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        
        <span class="c1">#Get homography matrix and homography points</span>
        <span class="n">hmatrix</span><span class="o">=</span><span class="n">homog</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">hpts</span><span class="o">=</span><span class="n">homog</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c1">#Apply perspective homography matrix to tracked points</span>
        <span class="n">dst_pts_homog</span> <span class="o">=</span> <span class="n">apply_persp_homographyPts</span><span class="p">(</span><span class="n">dst_pts_corr</span><span class="p">,</span>
                                                  <span class="n">hmatrix</span><span class="p">,</span>
                                                  <span class="n">inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="c1">#Calculate difference between points corrected for homography and</span>
        <span class="c1">#those uncorrected for homography</span>
        <span class="n">dispx</span><span class="o">=</span><span class="n">dst_pts_homog</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">src_pts_corr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dispy</span><span class="o">=</span><span class="n">dst_pts_homog</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">src_pts_corr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c1">#Use pythagoras&#39; theorem to obtain distance</span>
        <span class="n">disp_dist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dispx</span><span class="o">*</span><span class="n">dispx</span><span class="o">+</span><span class="n">dispy</span><span class="o">*</span><span class="n">dispy</span><span class="p">)</span>
        
        <span class="c1">#Determine threshold for good points using a given displacement </span>
        <span class="c1">#tolerance (defined earlier)</span>
        <span class="n">xsd</span><span class="o">=</span><span class="n">hpts</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">ysd</span><span class="o">=</span><span class="n">hpts</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">sderr</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">xsd</span><span class="o">*</span><span class="n">xsd</span><span class="o">+</span><span class="n">ysd</span><span class="o">*</span><span class="n">ysd</span><span class="p">)</span>
        <span class="n">good</span><span class="o">=</span><span class="n">disp_dist</span> <span class="o">&gt;</span> <span class="n">sderr</span> <span class="o">*</span> <span class="n">displacement_tolerance_rel</span>
        
        <span class="c1">#Keep good points</span>
        <span class="n">src_pts_corr</span><span class="o">=</span><span class="n">src_pts_corr</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>
        <span class="n">dst_pts_corr</span><span class="o">=</span><span class="n">dst_pts_corr</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>
        <span class="n">dst_pts_homog</span><span class="o">=</span><span class="n">dst_pts_homog</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>
        <span class="n">ptserrors</span><span class="o">=</span><span class="n">ptserrors</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>            
        
        <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">dst_pts_corr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> 
              <span class="s1">&#39; points remaining after homography correction&#39;</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#Original tracked points assigned if homography not given</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Homography matrix not supplied. Original tracked points kept&#39;</span><span class="p">)</span>
        <span class="n">dst_pts_homog</span><span class="o">=</span><span class="n">dst_pts_corr</span>
    
    <span class="c1">#Calculate pixel velocity</span>
    <span class="n">pxvel</span><span class="o">=</span><span class="p">[]</span>       
    <span class="k">for</span> <span class="n">c</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">src_pts_corr</span><span class="p">,</span> <span class="n">dst_pts_homog</span><span class="p">):</span>                        
        <span class="n">pxvel</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span>
                     <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])))</span>
        
    <span class="c1">#Project good points (original, tracked and back-tracked) to obtain XYZ </span>
    <span class="c1">#coordinates    </span>
    <span class="k">if</span> <span class="n">campars</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        
        <span class="c1">#Project good points from image0</span>
        <span class="n">uvs</span><span class="o">=</span><span class="n">src_pts_corr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="n">xyzs</span><span class="o">=</span><span class="n">projectUV</span><span class="p">(</span><span class="n">uvs</span><span class="p">,</span> <span class="n">campars</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        
        <span class="c1">#Project good points from image1</span>
        <span class="n">uvd</span><span class="o">=</span><span class="n">dst_pts_homog</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="n">xyzd</span><span class="o">=</span><span class="n">projectUV</span><span class="p">(</span><span class="n">uvd</span><span class="p">,</span> <span class="n">campars</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            
        <span class="c1">#Calculate xyz velocity</span>
        <span class="n">xyzvel</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xyzs</span><span class="p">,</span> <span class="n">xyzd</span><span class="p">):</span>                        
            <span class="n">xyzvel</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span>
                         <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
            
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xyzs</span><span class="o">=</span><span class="kc">None</span>
        <span class="n">xyzd</span><span class="o">=</span><span class="kc">None</span>
        <span class="n">xyzvel</span><span class="o">=</span><span class="kc">None</span>
            
    <span class="c1">#Return real-world point positions (original and tracked points),</span>
    <span class="c1">#and xy pixel positions (original, tracked, and homography-corrected)</span>
    <span class="k">if</span> <span class="n">homog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[[</span><span class="n">xyzvel</span><span class="p">,</span> <span class="n">xyzs</span><span class="p">,</span> <span class="n">xyzd</span><span class="p">],</span> 
                <span class="p">[</span><span class="n">pxvel</span><span class="p">,</span> <span class="n">src_pts_corr</span><span class="p">,</span> <span class="n">dst_pts_corr</span><span class="p">,</span> <span class="n">dst_pts_homog</span><span class="p">,</span> <span class="n">ptserrors</span><span class="p">]]</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[[</span><span class="n">xyzvel</span><span class="p">,</span> <span class="n">xyzs</span><span class="p">,</span> <span class="n">xyzd</span><span class="p">],</span> 
                <span class="p">[</span><span class="n">pxvel</span><span class="p">,</span> <span class="n">src_pts_corr</span><span class="p">,</span> <span class="n">dst_pts_corr</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ptserrors</span><span class="p">]]</span></div>

        
<div class="viewcode-block" id="calcSparseHomography"><a class="viewcode-back" href="../../source/Modules.html#PyTrx.Velocity.calcSparseHomography">[docs]</a><span class="k">def</span> <span class="nf">calcSparseHomography</span><span class="p">(</span><span class="n">img1</span><span class="p">,</span> <span class="n">img2</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">correct</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">RANSAC</span><span class="p">,</span> 
                         <span class="n">ransacReprojThreshold</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">winsize</span><span class="o">=</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span><span class="mi">25</span><span class="p">),</span> 
                         <span class="n">back_thresh</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">min_features</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> 
                         <span class="n">seedparams</span><span class="o">=</span><span class="p">[</span><span class="mi">50000</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;Function to supplement correction for movement in the camera </span>
<span class="sd">    platform given an image pair (i.e. image registration). Returns the </span>
<span class="sd">    homography representing tracked image movement, and the tracked </span>
<span class="sd">    features from each image.</span>

<span class="sd">    :param img1: Image 1 in the image pair</span>
<span class="sd">    :type img1: arr                 </span>
<span class="sd">    :param img2: Image 2 in the image pair</span>
<span class="sd">    :type img2: arr</span>
<span class="sd">    :param mask: Mask array for image points to be seeded</span>
<span class="sd">    :type mask: arr</span>
<span class="sd">    :param correct: Calibration parameters for correcting image for lens distortion, default to None</span>
<span class="sd">    :type correct: list, optional</span>
<span class="sd">    :param method: Method used to calculate homography model: cv2.RANSAC - RANSAC-based robust method; cv2.LEAST_MEDIAN - Least-Median robust; 0 - a regular method using all the points. Default to None</span>
<span class="sd">    :type method: int, optional</span>
<span class="sd">    :param ransacReprojThreshold: default to 5.0</span>
<span class="sd">    :type ransacReprojThreshold: int, optional</span>
<span class="sd">    :param winsize: default to (25, 25)</span>
<span class="sd">    :type winsize: tuple, optional</span>
<span class="sd">    :param back_thesh: Threshold for back-tracking distance (i.e.the difference between the original seeded point and the back-tracked point in im0); default to 1.0</span>
<span class="sd">    :type back_thresh: int, optional</span>
<span class="sd">    :param min_features: Minimum number of seeded points to track, default to 4</span>
<span class="sd">    :type min_features: int, optional</span>
<span class="sd">    :param seedparams: Point seeding parameters, which indicate whether points are generated based on corner features or a grid with defined spacing. The three corner features parameters denote maximum number of corners detected, corner quality, and minimum distance between corners; inputted as a list. For grid generation, the only input parameter needed is the grid spacing; inputted as a list containing the horizontal and vertical grid spacing. Default to [50000, 0.1, 5.0]</span>
<span class="sd">    :type seedparams: list, optional                           </span>
<span class="sd">    :returns: homogMatrix (arr) - The calculated homographic shift for the image pair; src_pts_corr (arr) - original homography points; dst_pts_corr (arr) - tracked homography points; homog_pts (arr) -back-tracked homography points; ptserror (list) - Difference between the original homography points and the back-tracked points; homogerror (list) -Difference between the interpolated homography matrix and the equivalent tracked points</span>
<span class="sd">    :rtype: arr/list</span>
<span class="sd">    &quot;&quot;&quot;</span>          
    <span class="c1">#Seed corner features</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="n">seedCorners</span><span class="p">(</span><span class="n">img1</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">seedparams</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seedparams</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">seedparams</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> 
                     <span class="n">min_features</span><span class="p">)</span>
        
    <span class="c1">#Feature track between images</span>
    <span class="n">points</span><span class="p">,</span> <span class="n">ptserrors</span> <span class="o">=</span> <span class="n">opticalMatch</span><span class="p">(</span><span class="n">img1</span><span class="p">,</span> <span class="n">img2</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">winsize</span><span class="p">,</span> <span class="n">back_thresh</span><span class="p">,</span> 
                                     <span class="n">min_features</span><span class="p">)</span> 
        
    <span class="c1">#Pass empty object if tracking insufficient</span>
    <span class="k">if</span> <span class="n">points</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">No features to undertake Homography&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
    
    <span class="k">if</span> <span class="n">correct</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        
        <span class="c1">#Calculate optimal camera matrix </span>
        <span class="n">size</span><span class="o">=</span><span class="n">img1</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">newMat</span><span class="p">,</span> <span class="n">roi</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">getOptimalNewCameraMatrix</span><span class="p">(</span><span class="n">correct</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                                                    <span class="n">correct</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> 
                                                    <span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">h</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">h</span><span class="p">))</span>
               
        <span class="c1">#Correct tracked points for image distortion. The homgraphy here is </span>
        <span class="c1">#defined forwards (i.e. the points in image 1 are first corrected, </span>
        <span class="c1">#followed by those in image 2)        </span>
        <span class="c1">#Correct points in first image  </span>
        <span class="n">src_pts_corr</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">undistortPoints</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                                         <span class="n">correct</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                                         <span class="n">correct</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">P</span><span class="o">=</span><span class="n">newMat</span><span class="p">)</span>
        
        <span class="c1">#Correct tracked points in second image</span>
        <span class="n">dst_pts_corr</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">undistortPoints</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> 
                                         <span class="n">correct</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                                         <span class="n">correct</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">P</span><span class="o">=</span><span class="n">newMat</span><span class="p">)</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="n">src_pts_corr</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dst_pts_corr</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="c1">#Find the homography between the two sets of corrected points</span>
    <span class="n">homogMatrix</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findHomography</span><span class="p">(</span><span class="n">src_pts_corr</span><span class="p">,</span> <span class="n">dst_pts_corr</span><span class="p">,</span> 
                                           <span class="n">method</span><span class="p">,</span> <span class="n">ransacReprojThreshold</span><span class="p">)</span>
    
    <span class="c1">#Calculate homography error</span>
    <span class="c1">#Apply global homography to source points</span>
    <span class="n">homog_pts</span> <span class="o">=</span> <span class="n">apply_persp_homographyPts</span><span class="p">(</span><span class="n">src_pts_corr</span><span class="p">,</span> <span class="n">homogMatrix</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>          

    <span class="c1">#Calculate offsets between tracked points and the modelled points </span>
    <span class="c1">#using the global homography</span>
    <span class="n">xd</span><span class="o">=</span><span class="n">dst_pts_corr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">homog_pts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">yd</span><span class="o">=</span><span class="n">dst_pts_corr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">homog_pts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="c1">#Calculate mean magnitude and standard deviations of the model </span>
    <span class="c1">#homography (i.e. actual point errors)          </span>
    <span class="n">xmean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xd</span><span class="p">)</span>       
    <span class="n">ymean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">yd</span><span class="p">)</span>       <span class="c1">#Mean should approximate to zero</span>
    <span class="n">xsd</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">xd</span><span class="p">)</span>          
    <span class="n">ysd</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">yd</span><span class="p">)</span>          <span class="c1">#SD indicates overall scale of error</span>

    <span class="c1">#Compile all error measures    </span>
    <span class="n">homogerrors</span><span class="o">=</span><span class="p">([</span><span class="n">xmean</span><span class="p">,</span><span class="n">ymean</span><span class="p">,</span><span class="n">xsd</span><span class="p">,</span><span class="n">ysd</span><span class="p">],[</span><span class="n">xd</span><span class="p">,</span><span class="n">yd</span><span class="p">])</span>
                
    <span class="k">return</span> <span class="p">(</span><span class="n">homogMatrix</span><span class="p">,</span> <span class="p">[</span><span class="n">src_pts_corr</span><span class="p">,</span><span class="n">dst_pts_corr</span><span class="p">,</span><span class="n">homog_pts</span><span class="p">],</span> <span class="n">ptserrors</span><span class="p">,</span> 
            <span class="n">homogerrors</span><span class="p">)</span></div>


<div class="viewcode-block" id="calcDenseHomography"><a class="viewcode-back" href="../../source/Modules.html#PyTrx.Velocity.calcDenseHomography">[docs]</a><span class="k">def</span> <span class="nf">calcDenseHomography</span><span class="p">(</span><span class="n">img1</span><span class="p">,</span> <span class="n">img2</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">correct</span><span class="p">,</span> <span class="n">griddistance</span><span class="p">,</span> <span class="n">templatesize</span><span class="p">,</span> 
                        <span class="n">searchsize</span><span class="p">,</span> <span class="n">dem</span><span class="p">,</span> <span class="n">projvars</span><span class="p">,</span> <span class="n">trackmethod</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">TM_CCORR_NORMED</span><span class="p">,</span> 
                        <span class="n">homogmethod</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">RANSAC</span><span class="p">,</span> <span class="n">ransacReprojThreshold</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> 
                        <span class="n">threshold</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">min_features</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to supplement correction for movement in the camera </span>
<span class="sd">    platform given an image pair (i.e. image registration). Returns the </span>
<span class="sd">    homography representing tracked image movement, and the tracked </span>
<span class="sd">    features from each image.</span>
<span class="sd">    </span>
<span class="sd">    :param img1: Image 1 in the image pair</span>
<span class="sd">    :type img1: arr</span>
<span class="sd">    :param img2: Image 2 in the image pair                  </span>
<span class="sd">    :type img2: arr </span>
<span class="sd">    :param mask: Mask array for image points to be seeded</span>
<span class="sd">    :type mask: arr</span>
<span class="sd">    :param correct: Calibration parameters for correcting image for lens distortion</span>
<span class="sd">    :type correct: list               </span>
<span class="sd">    :param griddistance: Grid spacing, defined by two values representing pixel row and column spacing</span>
<span class="sd">    :type griddistance: list</span>
<span class="sd">    :param templatesize: Template window size in im0 for matching</span>
<span class="sd">    :type templatesize: int</span>
<span class="sd">    :param searchsize: Search window size in im1 for matching</span>
<span class="sd">    :type searchsize: int  </span>
<span class="sd">    :param dem: :class:`PyTrx.DEM.ExplicitRaster` object</span>
<span class="sd">    :type dem: arr</span>
<span class="sd">    :param projvars: List containing projection parameters (camera location, camera position, radial distortion coefficients, tangential distortion coefficients, focal length, camera centre, and reference image)</span>
<span class="sd">    :type projvars: list    </span>
<span class="sd">    :param trackmethod: (str/int): Method for tmeplate matching: cv2.TM_CCOEFF - Cross-coefficient; cv2.TM_CCOEFF_NORMED - Normalised cross-coeff; cv2.TM_CCORR - Cross correlation; cv2.TM_CCORR_NORMED - Normalised cross-corr; cv2.TM_SQDIFF - Square difference; cv2.TM_SQDIFF_NORMED - Normalised square diff</span>
<span class="sd">    :type trackmethod: int</span>
<span class="sd">    :param homogmethod: Method used to calculate homography model: cv2.RANSAC - RANSAC-based robust method; cv2.LEAST_MEDIAN - Least-Median robust; 0 - a regular method using all the points. Default to None</span>
<span class="sd">    :type homogmethod: int, optional    </span>
<span class="sd">    :param ransacReprojThreshold: default to 5.0</span>
<span class="sd">    :type ransacReprojThreshold: int, optional       </span>
<span class="sd">    :param theshold: Threshold for template correlation; default to 0.8</span>
<span class="sd">    :type threshold: int, optional</span>
<span class="sd">    :param min_features: Minimum number of seeded points to track, default to 4</span>
<span class="sd">    :type min_features: int, optional                          </span>
<span class="sd">    :returns: homogMatrix (arr) - The calculated homographic shift for the image pair; src_pts_corr (arr) - original homography points; dst_pts_corr (arr) -  tracked homography points; homog_pts (arr) -back-tracked homography points;  ptserror (list) - Difference between the original homography points and the back-tracked points; homogerror (list) -Difference between the interpolated homography matrix and the equivalent tracked points</span>
<span class="sd">    :rtype: arr/list</span>
<span class="sd">    &quot;&quot;&quot;</span>         
    <span class="c1">#Generate grid for tracking</span>
    <span class="n">xyz0</span><span class="p">,</span> <span class="n">uv0</span> <span class="o">=</span> <span class="n">seedGrid</span><span class="p">(</span><span class="n">dem</span><span class="p">,</span> <span class="n">griddistance</span><span class="p">,</span> <span class="n">projvars</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
            
    <span class="c1">#Template match between images</span>
    <span class="n">points</span><span class="p">,</span> <span class="n">ptserrors</span> <span class="o">=</span> <span class="n">templateMatch</span><span class="p">(</span><span class="n">img1</span><span class="p">,</span> <span class="n">img2</span><span class="p">,</span> <span class="n">uv0</span><span class="p">,</span> <span class="n">templatesize</span><span class="p">,</span> <span class="n">searchsize</span><span class="p">,</span> 
                                      <span class="n">threshold</span><span class="p">,</span> <span class="n">min_features</span><span class="p">,</span> <span class="n">trackmethod</span><span class="p">)</span>
        
    <span class="c1">#Pass empty object if tracking insufficient</span>
    <span class="k">if</span> <span class="n">points</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">No features to undertake Homography&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
    
    <span class="k">if</span> <span class="n">correct</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        
        <span class="c1">#Calculate optimal camera matrix </span>
        <span class="n">size</span><span class="o">=</span><span class="n">img1</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">newMat</span><span class="p">,</span> <span class="n">roi</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">getOptimalNewCameraMatrix</span><span class="p">(</span><span class="n">correct</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                                                    <span class="n">correct</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> 
                                                    <span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">h</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">h</span><span class="p">))</span>
               
        <span class="c1">#Correct tracked points for image distortion. The homgraphy here is </span>
        <span class="c1">#defined forwards (i.e. the points in image 1 are first corrected, </span>
        <span class="c1">#followed by those in image 2)        </span>
        <span class="c1">#Correct points in first image  </span>
        <span class="n">src_pts_corr</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">undistortPoints</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                                         <span class="n">correct</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                                         <span class="n">correct</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">P</span><span class="o">=</span><span class="n">newMat</span><span class="p">)</span>
        
        <span class="c1">#Correct tracked points in second image</span>
        <span class="n">dst_pts_corr</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">undistortPoints</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> 
                                         <span class="n">correct</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                                         <span class="n">correct</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">P</span><span class="o">=</span><span class="n">newMat</span><span class="p">)</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="n">src_pts_corr</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dst_pts_corr</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="c1">#Find the homography between the two sets of corrected points</span>
    <span class="n">homogMatrix</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">findHomography</span><span class="p">(</span><span class="n">src_pts_corr</span><span class="p">,</span> <span class="n">dst_pts_corr</span><span class="p">,</span> 
                                           <span class="n">homogmethod</span><span class="p">,</span> <span class="n">ransacReprojThreshold</span><span class="p">)</span>
    
    <span class="c1">#Calculate homography error</span>
    <span class="c1">#Apply global homography to source points</span>
    <span class="n">homog_pts</span> <span class="o">=</span> <span class="n">apply_persp_homographyPts</span><span class="p">(</span><span class="n">src_pts_corr</span><span class="p">,</span> <span class="n">homogMatrix</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>          

    <span class="c1">#Calculate offsets between tracked points and the modelled points </span>
    <span class="c1">#using the global homography</span>
    <span class="n">xd</span><span class="o">=</span><span class="n">dst_pts_corr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">homog_pts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">yd</span><span class="o">=</span><span class="n">dst_pts_corr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">homog_pts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="c1">#Calculate mean magnitude and standard deviations of the model </span>
    <span class="c1">#homography (i.e. actual point errors)          </span>
    <span class="n">xmean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xd</span><span class="p">)</span>       
    <span class="n">ymean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">yd</span><span class="p">)</span>       <span class="c1">#Mean should approximate to zero</span>
    <span class="n">xsd</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">xd</span><span class="p">)</span>          
    <span class="n">ysd</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">yd</span><span class="p">)</span>          <span class="c1">#SD indicates overall scale of error</span>

    <span class="c1">#Compile all error measures    </span>
    <span class="n">homogerrors</span><span class="o">=</span><span class="p">([</span><span class="n">xmean</span><span class="p">,</span><span class="n">ymean</span><span class="p">,</span><span class="n">xsd</span><span class="p">,</span><span class="n">ysd</span><span class="p">],[</span><span class="n">xd</span><span class="p">,</span><span class="n">yd</span><span class="p">])</span>
                
    <span class="k">return</span> <span class="p">(</span><span class="n">homogMatrix</span><span class="p">,</span> <span class="p">[</span><span class="n">src_pts_corr</span><span class="p">,</span><span class="n">dst_pts_corr</span><span class="p">,</span><span class="n">homog_pts</span><span class="p">],</span> <span class="n">ptserrors</span><span class="p">,</span> 
            <span class="n">homogerrors</span><span class="p">)</span></div>
    

<div class="viewcode-block" id="apply_persp_homographyPts"><a class="viewcode-back" href="../../source/Modules.html#PyTrx.Velocity.apply_persp_homographyPts">[docs]</a><span class="k">def</span> <span class="nf">apply_persp_homographyPts</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">homog</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>        
    <span class="sd">&quot;&quot;&quot;Funtion to apply a perspective homography to a sequence of 2D </span>
<span class="sd">    values held in X and Y. The perspective homography is represented as a </span>
<span class="sd">    3 X 3 matrix (homog). The source points are inputted as an array. The </span>
<span class="sd">    homography perspective matrix is modelled in the same manner as done so </span>
<span class="sd">    in OpenCV.</span>
<span class="sd">    </span>
<span class="sd">    :param pts: Input point positions to correct</span>
<span class="sd">    :type pts: arr/list             </span>
<span class="sd">    :param homog: Perspective homography matrix </span>
<span class="sd">    :type homog: arr                                                 </span>
<span class="sd">    :param inverse:  Flag to denote if perspective homography matrix needs inversing, default to False</span>
<span class="sd">    :type inverse: bool, optional            </span>
<span class="sd">    :returns: corrected point positions</span>
<span class="sd">    :rtype: arr</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#If input is array         </span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">n</span><span class="o">=</span><span class="n">pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">hpts</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">pts</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
       
        <span class="k">if</span> <span class="n">inverse</span><span class="p">:</span>
           <span class="n">val</span><span class="p">,</span><span class="n">homog</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">homog</span><span class="p">)</span>       
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">div</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">homog</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">pts</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">homog</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">pts</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> 
                    <span class="n">homog</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">hpts</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="p">((</span><span class="n">homog</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">pts</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> 
                           <span class="n">homog</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">pts</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">homog</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">div</span><span class="p">)</span>
            <span class="n">hpts</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="p">((</span><span class="n">homog</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">pts</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> 
                            <span class="n">homog</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">pts</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">homog</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">div</span><span class="p">)</span>                          
        <span class="k">return</span> <span class="n">hpts</span> 
    
    <span class="c1">#If input is as list</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">hpts</span><span class="o">=</span><span class="p">[]</span>
               
        <span class="k">if</span> <span class="n">inverse</span><span class="p">:</span>
            <span class="n">val</span><span class="p">,</span><span class="n">homog</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">homog</span><span class="p">)</span> 

        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pts</span><span class="p">:</span>
            <span class="n">div</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">homog</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">homog</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">homog</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">xh</span><span class="o">=</span><span class="p">(</span><span class="n">homog</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">homog</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">homog</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">div</span>
            <span class="n">yh</span><span class="o">=</span><span class="p">(</span><span class="n">homog</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">homog</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">homog</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">div</span>
            <span class="n">hpts</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">xh</span><span class="p">,</span><span class="n">yh</span><span class="p">])</span>
        
        <span class="k">return</span> <span class="n">hpts</span>
    
    <span class="c1">#If input is incompatible</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;PERPECTIVE INPUT: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">pts</span><span class="p">)))</span>
        <span class="n">hpts</span><span class="o">=</span><span class="kc">None</span>
              
        <span class="k">return</span> <span class="n">hpts</span> </div>
        

<div class="viewcode-block" id="opticalMatch"><a class="viewcode-back" href="../../source/Modules.html#PyTrx.Velocity.opticalMatch">[docs]</a><span class="k">def</span> <span class="nf">opticalMatch</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">iN</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">winsize</span><span class="p">,</span> <span class="n">back_thresh</span><span class="p">,</span> <span class="n">min_features</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to match between two masked images using Optical Flow. The </span>
<span class="sd">    Lucas Kanade optical flow algorithm is applied using the OpenCV function </span>
<span class="sd">    calcOpticalFlowPyrLK to find these tracked points in the second image. A </span>
<span class="sd">    backward tracking then tracks back from these to the original points, </span>
<span class="sd">    checking if this is within a given number of pixels as a validation </span>
<span class="sd">    measure. The resulting error is the difference between the original feature </span>
<span class="sd">    point and the backtracked feature point. </span>
<span class="sd">    </span>
<span class="sd">    :param i0: Image 1 in the image pair</span>
<span class="sd">    :type i0: arr</span>
<span class="sd">    :param iN: Image 2 in the image pair</span>
<span class="sd">    :type iN: arr</span>
<span class="sd">    :param winsize: Window size for tracking e.g. (25,25)</span>
<span class="sd">    :type winsize: tuple</span>
<span class="sd">    :param back_thesh: Threshold for back-tracking distance (i.e. the difference between the original seeded point and the back-tracked point in im0)</span>
<span class="sd">    :type back_thresh: int</span>
<span class="sd">    :param min_features: Minimum number of seeded points to track</span>
<span class="sd">    :type min_features: int   </span>
<span class="sd">    :return: Point coordinates for points tracked to image 2 (arr), Point coordinates for points back-tracked from image 2 to image 1 (arr), and SNR measurements for the corresponding tracked point. The signal is the magnitude of the displacement from p0 to p1, and the noise is the magnitude of the displacement from p0r to p0 (arr)</span>
<span class="sd">    :rtype: arr</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Feature tracking set-up parameters</span>
    <span class="n">lk_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span> <span class="n">winSize</span>  <span class="o">=</span> <span class="n">winsize</span><span class="p">,</span>
                      <span class="n">maxLevel</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
                      <span class="n">criteria</span> <span class="o">=</span> <span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">TERM_CRITERIA_EPS</span> <span class="o">|</span> 
                                  <span class="n">cv2</span><span class="o">.</span><span class="n">TERM_CRITERIA_COUNT</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">))</span>
        
    <span class="c1">#Track forward from im0 to im1. p1 is returned as an array of shape</span>
    <span class="c1">#(n,1,2), where n is the number of features tracked</span>
    <span class="n">p1</span><span class="p">,</span> <span class="n">status1</span><span class="p">,</span> <span class="n">error1</span>  <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">calcOpticalFlowPyrLK</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">iN</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> 
                                                    <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">lk_params</span><span class="p">)</span> 
                                                    
    <span class="c1">#Track backwards from im1 to im0 using the forward-tracked points</span>
    <span class="n">p0r</span><span class="p">,</span> <span class="n">status0</span><span class="p">,</span> <span class="n">error0</span>  <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">calcOpticalFlowPyrLK</span><span class="p">(</span><span class="n">iN</span><span class="p">,</span> <span class="n">i0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> 
                                                     <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">lk_params</span><span class="p">)</span>         
   
    <span class="c1">#Find euclidian pixel distance beween original(p0) and backtracked </span>
    <span class="c1">#(p0r) points and discard point greater than the threshold. This is </span>
    <span class="c1">#a way of checking tracking robustness</span>
    <span class="n">dist</span><span class="o">=</span><span class="p">(</span><span class="n">p0</span><span class="o">-</span><span class="n">p0r</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">p0</span><span class="o">-</span><span class="n">p0r</span><span class="p">)</span>
    <span class="n">dist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dist</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">dist</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>            
    <span class="n">tracked</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
    <span class="n">good</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">back_thresh</span>
    
    <span class="c1">#Points are boolean filtered by the backtracking success </span>
    <span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>
    <span class="n">p1</span><span class="o">=</span><span class="n">p1</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>
    <span class="n">p0r</span><span class="o">=</span><span class="n">p0r</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>
    <span class="n">error</span><span class="o">=</span><span class="n">dist</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Average back-tracking difference: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">good</span><span class="p">)))</span>

    <span class="c1">#Return None if number of tracked features is under the </span>
    <span class="c1">#min_features threshold</span>
    <span class="k">if</span> <span class="n">p0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">min_features</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Not enough features successfully tracked.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
           
    <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">tracked</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; features tracked&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">p0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span><span class="s1">&#39; features remaining after forward-backward error&#39;</span><span class="p">)</span>
       
    <span class="k">return</span> <span class="p">[</span><span class="n">p0</span><span class="p">,</span><span class="n">p1</span><span class="p">,</span><span class="n">p0r</span><span class="p">],</span> <span class="n">error</span></div>


<div class="viewcode-block" id="templateMatch"><a class="viewcode-back" href="../../source/Modules.html#PyTrx.Velocity.templateMatch">[docs]</a><span class="k">def</span> <span class="nf">templateMatch</span><span class="p">(</span><span class="n">im0</span><span class="p">,</span> <span class="n">im1</span><span class="p">,</span> <span class="n">uv0</span><span class="p">,</span> <span class="n">templatesize</span><span class="p">,</span> <span class="n">searchsize</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
                  <span class="n">min_features</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">TM_CCORR_NORMED</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to template match between two images. Templates in the first</span>
<span class="sd">    image (im0) are generated from a given set of points (uv0) and matched to </span>
<span class="sd">    the search window in image 2 (im1). There are a series of methods that can</span>
<span class="sd">    be used for matching, in adherence with those offered with OpenCV&#39;s </span>
<span class="sd">    matchTemplate function. After matching, the origin point of each matched </span>
<span class="sd">    template in image 2 is returned, along with the average correlation in </span>
<span class="sd">    each template.</span>
<span class="sd">                                    </span>
<span class="sd">    :param im0: Image 1 in the image pair</span>
<span class="sd">    :type im0: arr</span>
<span class="sd">    :param im1: Image 2 in the image pair                  </span>
<span class="sd">    :type im1: arr                  </span>
<span class="sd">    :param uv0: Grid points for image 1</span>
<span class="sd">    :type uv0: tuple</span>
<span class="sd">    :param templatesize: Template window size in im0 for matching</span>
<span class="sd">    :type templatesize: int</span>
<span class="sd">    :param searchsize: Search window size in im1 for matching</span>
<span class="sd">    :type searchsize: int   </span>
<span class="sd">    :param min_features: Minimum number of seeded points to track, default to 4</span>
<span class="sd">    :type min_features: int, optional   </span>
<span class="sd">    :param method: (str/int): Method for tmeplate matching: cv2.TM_CCOEFF - Cross-coefficient; cv2.TM_CCOEFF_NORMED - Normalised cross-coeff; cv2.TM_CCORR - Cross correlation; cv2.TM_CCORR_NORMED - Normalised cross-corr; cv2.TM_SQDIFF - Square difference; cv2.TM_SQDIFF_NORMED - Normalised square diff</span>
<span class="sd">    :type method: int</span>
<span class="sd">    :returns: Point coordinates for points tracked to image 2 (arr), Point coordinates for points back-tracked from image 2 to image 1 (arr), and SNR measurements for the corresponding tracked point where the signal is the magnitude of the displacement from p0 to p1, and the noise is the magnitude of the displacement from p0r to p0 (arr)</span>
<span class="sd">    :rtype: arr</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Create empty outputs</span>
    <span class="n">avercorr</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">pu1</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">pv1</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">pu2</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">pv2</span><span class="o">=</span><span class="p">[]</span>        
    
    <span class="c1">#Iterate through points</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">uv0</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">uv0</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">]):</span>
         
        <span class="c1">#Get template and search window for point</span>
        <span class="n">template</span> <span class="o">=</span> <span class="n">im0</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="o">-</span><span class="p">(</span><span class="n">templatesize</span><span class="o">/</span><span class="mi">2</span><span class="p">)):</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="p">(</span><span class="n">templatesize</span><span class="o">/</span><span class="mi">2</span><span class="p">)),</span> 
                      <span class="nb">int</span><span class="p">(</span><span class="n">u</span><span class="o">-</span><span class="p">(</span><span class="n">templatesize</span><span class="o">/</span><span class="mi">2</span><span class="p">)):</span><span class="nb">int</span><span class="p">(</span><span class="n">u</span><span class="o">+</span><span class="p">(</span><span class="n">templatesize</span><span class="o">/</span><span class="mi">2</span><span class="p">))]</span>
        <span class="n">search</span> <span class="o">=</span> <span class="n">im1</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="o">-</span><span class="p">(</span><span class="n">searchsize</span><span class="o">/</span><span class="mi">2</span><span class="p">)):</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="p">(</span><span class="n">searchsize</span><span class="o">/</span><span class="mi">2</span><span class="p">)),</span> 
                    <span class="nb">int</span><span class="p">(</span><span class="n">u</span><span class="o">-</span><span class="p">(</span><span class="n">searchsize</span><span class="o">/</span><span class="mi">2</span><span class="p">)):</span><span class="nb">int</span><span class="p">(</span><span class="n">u</span><span class="o">+</span><span class="p">(</span><span class="n">searchsize</span><span class="o">/</span><span class="mi">2</span><span class="p">))]</span>       
               
        <span class="c1">#Change array values from float64 to uint8</span>
        <span class="n">template</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">search</span> <span class="o">=</span> <span class="n">search</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
                      
        <span class="c1">#Define method string as mapping object</span>
        <span class="n">meth</span><span class="o">=</span><span class="nb">eval</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
                   
        <span class="c1">#Attempt to match template in imageA to search window in imageB </span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">resz</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">matchTemplate</span><span class="p">(</span><span class="n">search</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">meth</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">continue</span>    
                                        
        <span class="c1">#Create UV meshgrid for correlation result </span>
        <span class="n">resx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">resz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">resy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">resz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>                    
        <span class="n">resx</span><span class="p">,</span><span class="n">resy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">resx</span><span class="p">,</span> <span class="n">resy</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                                                
        <span class="c1">#Create bicubic interpolation grid                                                                            </span>
        <span class="n">interp</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp2d</span><span class="p">(</span><span class="n">resx</span><span class="p">,</span> <span class="n">resy</span><span class="p">,</span> <span class="n">resz</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">)</span>                    
        
        <span class="c1">#Create sub-pixel UV grid to interpolate across</span>
        <span class="n">subpx</span> <span class="o">=</span> <span class="mf">0.01</span>
        <span class="n">newx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">resz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">subpx</span><span class="p">)</span>
        <span class="n">newy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">resz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">subpx</span><span class="p">)</span>
                
        <span class="c1">#Interpolate new correlation grid</span>
        <span class="n">resz</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">newx</span><span class="p">,</span> <span class="n">newy</span><span class="p">)</span>
                                                
        <span class="c1">#Get correlation values and coordinate locations        </span>
        <span class="n">min_val</span><span class="p">,</span> <span class="n">max_val</span><span class="p">,</span> <span class="n">min_loc</span><span class="p">,</span> <span class="n">max_loc</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">minMaxLoc</span><span class="p">(</span><span class="n">resz</span><span class="p">)</span>

        <span class="c1">#If the method is TM_SQDIFF or TM_SQDIFF_NORMED, take minimum </span>
        <span class="c1">#location</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;cv2.TM_SQDIFF&#39;</span><span class="p">:</span>                            
            <span class="n">location</span> <span class="o">=</span> <span class="n">min_loc</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;cv2.TM_SQDIFF_NORMED&#39;</span><span class="p">:</span>
            <span class="n">location</span> <span class="o">=</span> <span class="n">min_loc</span>
            
        <span class="c1">#Else, take maximum location</span>
        <span class="k">else</span><span class="p">:</span>                 
            <span class="n">location</span> <span class="o">=</span> <span class="n">max_loc</span>
         
        <span class="c1">#Retain point if mean correlation value is above threshold</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">resz</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>
            
            <span class="c1">#Calculate tracked point location, assuming the origin of the </span>
            <span class="c1">#template window is the same as the origin of the correlation array                    </span>
            <span class="n">loc_x</span> <span class="o">=</span> <span class="p">((</span><span class="n">u</span> <span class="o">-</span> <span class="p">((</span><span class="n">resz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">subpx</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span> <span class="o">+</span> 
                    <span class="p">(</span><span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">subpx</span><span class="p">))</span>
            <span class="n">loc_y</span> <span class="o">=</span> <span class="p">((</span><span class="n">v</span> <span class="o">-</span> <span class="p">((</span><span class="n">resz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">subpx</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> 
                    <span class="p">(</span><span class="n">location</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">subpx</span><span class="p">)))</span>                            
        
            <span class="c1">#Retain correlation and location            </span>
            <span class="n">avercorr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">resz</span><span class="p">))</span>
            <span class="n">pu1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="n">pv1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">pu2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loc_x</span><span class="p">)</span>
            <span class="n">pv2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loc_y</span><span class="p">)</span>
            
            
    <span class="c1">#Reshape all points and average correlations in 3D arrays</span>
    <span class="n">uv0t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">pu1</span><span class="p">,</span><span class="n">pv1</span><span class="p">])</span>
    <span class="n">uv0t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">uv0t</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>    
    <span class="n">uv1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">pu2</span><span class="p">,</span> <span class="n">pv2</span><span class="p">])</span>            
    <span class="n">uv1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">uv1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">avercorr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">avercorr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
    
    <span class="c1">#Return none if not enough templates were matched, else return all</span>
    <span class="k">if</span> <span class="n">uv1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">min_features</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Not enough templates successfully matched.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Average template correlation: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">avercorr</span><span class="p">)))</span>               
        <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">uv1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39; templates tracked&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">uv0t</span><span class="p">,</span> <span class="n">uv1</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">avercorr</span></div>


<div class="viewcode-block" id="seedCorners"><a class="viewcode-back" href="../../source/Modules.html#PyTrx.Velocity.seedCorners">[docs]</a><span class="k">def</span> <span class="nf">seedCorners</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">maxpoints</span><span class="p">,</span> <span class="n">quality</span><span class="p">,</span> <span class="n">mindist</span><span class="p">,</span> <span class="n">min_features</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to seed corner features using the Shi-Tomasi corner feature </span>
<span class="sd">    detection method in OpenCV&#39;s goodFeaturesToTrack function. </span>
<span class="sd">        </span>
<span class="sd">    :param img: Image for seeding corner points</span>
<span class="sd">    :type img: arr                 </span>
<span class="sd">    :param mask: Mask array for points to be seeded</span>
<span class="sd">    :type mask: arr</span>
<span class="sd">    :param maxpoints: Maximum number of corners detected</span>
<span class="sd">    :type maxpoints: int   </span>
<span class="sd">    :param quality: Corner quality (between 0.0 and 1.0)</span>
<span class="sd">    :type quality: int </span>
<span class="sd">    :param mindist: Minimum distance between corners</span>
<span class="sd">    :type mindist: int </span>
<span class="sd">    :param min_features: Minimum number of seeded points to track</span>
<span class="sd">    :type min_features: int</span>
<span class="sd">    :returns: Point coordinates for corner features seeded in image </span>
<span class="sd">    :rtype: arr</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="c1">#Find corners of the first image. p0 is returned as an array of shape </span>
    <span class="c1">#(n,1,2), where n is the number of features identified </span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>       
        <span class="n">p0</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">goodFeaturesToTrack</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">maxpoints</span><span class="p">,</span><span class="n">quality</span><span class="p">,</span><span class="n">mindist</span><span class="p">,</span><span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p0</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">goodFeaturesToTrack</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">maxpoints</span><span class="p">,</span><span class="n">quality</span><span class="p">,</span><span class="n">mindist</span><span class="p">)</span>
        
    <span class="c1">#tracked is the number of features returned by goodFeaturesToTrack        </span>
    <span class="n">tracked</span><span class="o">=</span><span class="n">p0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            
    <span class="c1">#Check if there are enough points to initially track </span>
    <span class="k">if</span> <span class="n">tracked</span><span class="o">&lt;</span><span class="n">min_features</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Not enough features found to track. Found: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p0</span><span class="p">)))</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">p0</span></div>


<div class="viewcode-block" id="seedGrid"><a class="viewcode-back" href="../../source/Modules.html#PyTrx.Velocity.seedGrid">[docs]</a><span class="k">def</span> <span class="nf">seedGrid</span><span class="p">(</span><span class="n">dem</span><span class="p">,</span> <span class="n">griddistance</span><span class="p">,</span> <span class="n">projvars</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Define pixel grid at a specified grid distance, taking into </span>
<span class="sd">    consideration the image size and image mask.</span>
<span class="sd">    </span>
<span class="sd">    :param dem: :class:`PyTrx.DEM.ExplicitRaster` DEM object</span>
<span class="sd">    :type dem: arr          </span>
<span class="sd">    :param griddistance: Grid spacing, defined by two values representing pixel row and column spacing.</span>
<span class="sd">    :type griddistance: list</span>
<span class="sd">    :param projvars: Projection parameters (camera location, camera position, radial distortion coefficients, tangential distortion coefficients, focal length, camera centre, and reference image)</span>
<span class="sd">    :type projvars: list         </span>
<span class="sd">    :param mask: Mask array for masking DEM</span>
<span class="sd">    :type mask: arr</span>
<span class="sd">    :returns: Two arrays containing the grid point positions in the DEM coordinate system (arr), and the grid point positions in the image coordinate system (arr)</span>
<span class="sd">    :rtype: arr</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Get DEM z values</span>
    <span class="n">demz</span> <span class="o">=</span> <span class="n">dem</span><span class="o">.</span><span class="n">getZ</span><span class="p">()</span>

    <span class="c1">#Get mask and fill masked demz values with NaN values</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">demz</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">demz</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>
        <span class="n">demz</span> <span class="o">=</span> <span class="n">demz</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> 
        
    <span class="c1">#Get DEM extent</span>
    <span class="n">extent</span> <span class="o">=</span> <span class="n">dem</span><span class="o">.</span><span class="n">getExtent</span><span class="p">()</span>
    
    <span class="c1">#Define point spacings in dem space</span>
    <span class="n">samplex</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">griddistance</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">sampley</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">griddistance</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="c1">#Define grid in dem space</span>
    <span class="n">linx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">samplex</span><span class="p">)</span>
    <span class="n">liny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">sampley</span><span class="p">)</span>
    
    <span class="c1">#Create mesh of grid points</span>
    <span class="n">meshx</span><span class="p">,</span> <span class="n">meshy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">linx</span><span class="p">,</span> <span class="n">liny</span><span class="p">)</span> 
    
    <span class="c1">#Get unique DEM row and column values   </span>
    <span class="n">demx</span> <span class="o">=</span> <span class="n">dem</span><span class="o">.</span><span class="n">getData</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>    
    <span class="n">demx_uniq</span> <span class="o">=</span> <span class="n">demx</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
    <span class="n">demx_uniq</span> <span class="o">=</span> <span class="n">demx_uniq</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">demx_uniq</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>    
    <span class="n">demy</span> <span class="o">=</span> <span class="n">dem</span><span class="o">.</span><span class="n">getData</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">demy_uniq</span> <span class="o">=</span> <span class="n">demy</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>    
    <span class="n">demy_uniq</span> <span class="o">=</span> <span class="n">demy_uniq</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">demy_uniq</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1">#Get Z values for mesh grid</span>
    <span class="n">meshx2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">meshy2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">meshz2</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1">#Go through all positions in mesh grid    </span>
    <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">meshx</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">meshy</span><span class="o">.</span><span class="n">flatten</span><span class="p">()):</span>

        <span class="c1">#Find mesh grid point in DEM and return indexes</span>
        <span class="n">indx_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">demx_uniq</span><span class="o">-</span><span class="n">a</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="n">indx_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">demy_uniq</span><span class="o">-</span><span class="n">b</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>

        <span class="c1">#Append Z value if not NaN (i.e. masked out in DEM)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">demz</span><span class="p">[</span><span class="n">indx_y</span><span class="p">,</span><span class="n">indx_x</span><span class="p">])</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">meshx2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">meshy2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">meshz2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">demz</span><span class="p">[</span><span class="n">indx_y</span><span class="p">,</span><span class="n">indx_x</span><span class="p">])</span>
    
    <span class="c1">#Compile grid X, Y, Z components together</span>
    <span class="n">xyz</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">meshx2</span><span class="p">,</span><span class="n">meshy2</span><span class="p">,</span><span class="n">meshz2</span><span class="p">])</span>

    <span class="c1">#Project xyz grid to image plane</span>
    <span class="n">uv</span><span class="p">,</span><span class="n">depth</span><span class="p">,</span><span class="n">inframe</span> <span class="o">=</span> <span class="n">projectXYZ</span><span class="p">(</span><span class="n">projvars</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">projvars</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">projvars</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> 
                                  <span class="n">projvars</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">projvars</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">projvars</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> 
                                  <span class="n">projvars</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">xyz</span><span class="p">)</span>
    
    <span class="c1">#Reshape UV array, </span>
    <span class="n">uv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>  
    
    <span class="k">return</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">uv</span></div>

<div class="viewcode-block" id="readDEMmask"><a class="viewcode-back" href="../../source/Modules.html#PyTrx.Velocity.readDEMmask">[docs]</a><span class="k">def</span> <span class="nf">readDEMmask</span><span class="p">(</span><span class="n">dem</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">invprojvars</span><span class="p">,</span> <span class="n">demMaskPath</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Read/generate DEM mask for subsequent grid generation. If a valid </span>
<span class="sd">    filename is given then the DEM mask is loaded from file. If the filename</span>
<span class="sd">    does not exist, then the mask is defined. To define the DEM mask, a mask is</span>
<span class="sd">    first defined in the image plane (using point and click, facilitated </span>
<span class="sd">    through Matplotlib Pyplot&#39;s ginput function), and then projected to the </span>
<span class="sd">    DEM scene using CamEnv&#39;s projectXYZ function. For the projection to work,</span>
<span class="sd">    the invprojvars need to be valid X,Y,Z,uv0 parameters, as generated in </span>
<span class="sd">    CamEnv&#39;s setProjection function. The mask is saved to file if a filepath is</span>
<span class="sd">    given. This DEM mask can be used for dense feature-tracking/template </span>
<span class="sd">    matching, where masked regions of the DEM are reassigned to </span>
<span class="sd">    NaN using Numpy&#39;s ma.mask function.</span>
<span class="sd">    </span>
<span class="sd">    :param dem: :class:`PyTrx.DEM.ExplicitRaster` DEM object</span>
<span class="sd">    :type dem: arr          </span>
<span class="sd">    :param img: Image to initially define mask in</span>
<span class="sd">    :type img: arr</span>
<span class="sd">    :param invprojvars: Inverse projection variables [X,Y,Z,uv0]</span>
<span class="sd">    :type invprojvars: list         </span>
<span class="sd">    :param demMaskPath: File path to outputted mask file, default to None</span>
<span class="sd">    :type demMaskPath: str, optional</span>
<span class="sd">    :returns: A Boolean visibility matrix (which is the same dimensions as the dem)</span>
<span class="sd">    :rtype: arr</span>
<span class="sd">    &quot;&quot;&quot;</span>   
    <span class="c1">#Check if a DEM mask already exists, if not enter digitising</span>
    <span class="k">if</span> <span class="n">demMaskPath</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">demMask</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">demMaskPath</span><span class="p">)</span>
            <span class="n">demMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">demMask</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">DEM mask loaded&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">demMask</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">DEM mask file not found. Proceeding to manually digitise...&#39;</span><span class="p">)</span>
    
    <span class="c1">#Open image in figure plot </span>
    <span class="n">fig</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">set_window_title</span><span class="p">(</span><span class="s1">&#39;Click to create mask. Press enter to record&#39;</span> 
                                <span class="s1">&#39; points.&#39;</span><span class="p">)</span>
    <span class="n">imgplot</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;upper&#39;</span><span class="p">)</span>
    <span class="n">imgplot</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
    
    <span class="c1">#Initiate interactive point and click</span>
    <span class="n">uv</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">ginput</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">show_clicks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mouse_add</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mouse_pop</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> 
                    <span class="n">mouse_stop</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uv</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39; points seeded&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="c1">#Close shape</span>
    <span class="n">uv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uv</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="c1">#Reshape array and project to DEM    </span>
    <span class="n">uv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">uv</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">projectUV</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">invprojvars</span><span class="p">)</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">xyz</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">xyz</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]])</span> 
    
    <span class="c1">#Get unique row and column data from DEM</span>
    <span class="n">demx</span> <span class="o">=</span> <span class="n">dem</span><span class="o">.</span><span class="n">getData</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>    
    <span class="n">demx_uniq</span> <span class="o">=</span> <span class="n">demx</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
    <span class="n">demx_uniq</span> <span class="o">=</span> <span class="n">demx_uniq</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">demx_uniq</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>    
    <span class="n">demy</span> <span class="o">=</span> <span class="n">dem</span><span class="o">.</span><span class="n">getData</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">demy_uniq</span> <span class="o">=</span> <span class="n">demy</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> 
    <span class="n">demy_uniq</span> <span class="o">=</span> <span class="n">demy_uniq</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">demy_uniq</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1">#Create meshgrid of DEM XY coordinates</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">demx_uniq</span><span class="p">,</span> <span class="n">demy_uniq</span><span class="p">)</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    
    <span class="c1">#Overlay mask onto meshgrid and reshape as DEM</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
    <span class="n">demMask</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">contains_points</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="n">demMask</span> <span class="o">=</span> <span class="n">demMask</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">demy_uniq</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">demx_uniq</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    
    <span class="c1">#Save mask to file if file path is specified</span>
    <span class="k">if</span> <span class="n">demMaskPath</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">demMask</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s1">&#39;L&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">demMaskPath</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Saved DEM mask to: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">demMaskPath</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Failed to write file: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">demMaskPath</span><span class="p">))</span>
        
    <span class="k">return</span> <span class="n">demMask</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">PyTrx 1.1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Penelope How, Nick Hulton, Lynne Buie.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.0.
    </div>
  </body>
</html>